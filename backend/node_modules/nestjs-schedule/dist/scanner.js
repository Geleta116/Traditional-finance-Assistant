"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Scanner = void 0;
const tslib_1 = require("tslib");
const common_1 = require("@nestjs/common");
const core_1 = require("@nestjs/core");
const constants_1 = require("@nestjs/core/injector/constants");
let Scanner = class Scanner {
    constructor(discoveryService) {
        this.discoveryService = discoveryService;
    }
    onModuleInit() {
        this.container = this.findContainer();
    }
    findInjectable(metaType) {
        var _a;
        if (metaType) {
            const modules = (_a = this.container) === null || _a === void 0 ? void 0 : _a.getModules().values();
            for (const module of modules) {
                if (!module.injectables.size) {
                    continue;
                }
                let instanceWrapper = module.injectables.get(metaType);
                if (!instanceWrapper) {
                    instanceWrapper = module.injectables.get(metaType.name);
                }
                if (instanceWrapper && instanceWrapper.metatype === metaType) {
                    const instanceHost = instanceWrapper.getInstanceByContextId(constants_1.STATIC_CONTEXT);
                    if (instanceHost.isResolved && instanceHost.instance) {
                        return instanceHost.instance;
                    }
                }
            }
        }
        return undefined;
    }
    findProviderByName(name) {
        const modules = this.container.getModules().values();
        for (const module of modules) {
            const instanceWrapper = module.providers.get(name);
            if (instanceWrapper && module.providers.has(name)) {
                const instanceWrapper = module.providers.get(name);
                if (instanceWrapper) {
                    const instanceHost = instanceWrapper.getInstanceByContextId(constants_1.STATIC_CONTEXT);
                    if (instanceHost.isResolved && instanceHost.instance) {
                        return instanceHost.instance;
                    }
                }
            }
        }
        return undefined;
    }
    findContainer() {
        const providers = this.discoveryService.getProviders();
        if (providers.length === 0) {
            return;
        }
        const module = providers[0].host;
        return module.container;
    }
    findContextModule(constructor) {
        const className = constructor.name;
        if (!className) {
            return;
        }
        for (const [, module] of [...this.container.getModules().entries()]) {
            if (this.findProviderByClassName(module, className)) {
                return module;
            }
        }
        return;
    }
    findContextModuleName(constructor) {
        const className = constructor.name;
        if (!className) {
            return '';
        }
        for (const [key, module] of [
            ...this.container.getModules().entries(),
        ]) {
            if (this.findProviderByClassName(module, className)) {
                return key;
            }
        }
        return '';
    }
    findInjectableInstance(context, metaTypeOrName) {
        const collection = this.container.getModules();
        const module = collection.get(context);
        if (!module) {
            return undefined;
        }
        const injectables = module.injectables;
        return injectables.get(typeof metaTypeOrName === 'string'
            ? metaTypeOrName
            : metaTypeOrName.name);
    }
    findProviderInstance(context, metaTypeOrName) {
        const collection = this.container.getModules();
        const module = collection.get(context);
        if (!module) {
            return undefined;
        }
        const providers = module.providers;
        return providers.get(typeof metaTypeOrName === 'string'
            ? metaTypeOrName
            : metaTypeOrName.name);
    }
    findProviderByClassName(module, className) {
        const { providers } = module;
        const hasProvider = [...providers.keys()].some(provider => provider === className);
        return hasProvider;
    }
};
Scanner = tslib_1.__decorate([
    (0, common_1.Injectable)(),
    tslib_1.__metadata("design:paramtypes", [core_1.DiscoveryService])
], Scanner);
exports.Scanner = Scanner;
