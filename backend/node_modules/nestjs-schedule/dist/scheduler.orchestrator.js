"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SchedulerOrchestrator = void 0;
const tslib_1 = require("tslib");
const common_1 = require("@nestjs/common");
const uuid_1 = require("uuid");
const node_schedule_1 = require("node-schedule");
const scheduler_registry_1 = require("./scheduler.registry");
const schedule_wrapper_1 = require("./schedule.wrapper");
const schedule_messages_1 = require("./schedule.messages");
let SchedulerOrchestrator = class SchedulerOrchestrator {
    constructor(registry, wrapper) {
        this.registry = registry;
        this.wrapper = wrapper;
        this.logger = new common_1.Logger('Schedule');
    }
    onApplicationBootstrap() {
        this.mountTimeouts();
        this.mountIntervals();
        this.mountCron();
    }
    onApplicationShutdown() {
        this.clearTimeouts();
        this.clearIntervals();
        this.closeCronJobs();
    }
    mountIntervals() {
        this.registry.getIntervalJobs().forEach((job, name) => {
            const { options = {}, interval, target, locker, ref } = job;
            if (ref) {
                return;
            }
            let methodRef = this.wrapper.retryable(target, options.retries, options.retry);
            if (options.immediate) {
                methodRef = this.wrapper.immediately(name, methodRef);
            }
            methodRef = this.wrapper.lockable(methodRef, name, locker);
            job.ref = setInterval(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
                try {
                    yield (yield methodRef).call(null);
                }
                catch (e) {
                    this.logger.error((0, schedule_messages_1.JOB_EXECUTE_ERROR)(name), e);
                }
            }), interval);
        });
    }
    mountTimeouts() {
        this.registry.getTimeoutJobs().forEach((job, name) => {
            const { options = {}, timeout, target, locker, ref } = job;
            if (ref) {
                return;
            }
            const methodRef = this.wrapper.lockable(this.wrapper.retryable(target, options.retries, options.retry), name, locker);
            job.ref = setTimeout(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
                try {
                    yield (yield methodRef).call(null);
                }
                catch (e) {
                    this.logger.error((0, schedule_messages_1.JOB_EXECUTE_ERROR)(name), e);
                }
            }), timeout);
        });
    }
    mountCron() {
        this.registry.getCronJobs().forEach((job, name) => {
            const { options = {}, target, rule, locker, ref } = job;
            if (ref) {
                return;
            }
            const methodRef = this.wrapper.lockable(this.wrapper.retryable(target, options.retries, options.retry), name, locker);
            job.ref = (0, node_schedule_1.scheduleJob)(name, rule, () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                try {
                    yield (yield methodRef).call(null);
                }
                catch (e) {
                    this.logger.error((0, schedule_messages_1.JOB_EXECUTE_ERROR)(name), e);
                }
            }));
        });
    }
    clearTimeouts() {
        this.registry.getTimeoutJobs().forEach((job) => clearTimeout(job.ref));
    }
    clearIntervals() {
        this.registry
            .getIntervalJobs()
            .forEach((job) => clearInterval(job.ref));
    }
    closeCronJobs() {
        this.registry.getCronJobs().forEach((job) => job.ref.cancel());
    }
    addTimeout(methodRef, timeout, name, locker, options) {
        this.registry.addTimeoutJob(name, {
            target: methodRef,
            timeout,
            locker,
            options,
        });
    }
    addInterval(methodRef, interval, name, locker, options) {
        this.registry.addIntervalJob(name, {
            target: methodRef,
            interval,
            locker,
            options,
        });
    }
    addCron(methodRef, rule, locker, options) {
        const name = options ? options.name || (0, uuid_1.v4)() : (0, uuid_1.v4)();
        this.registry.addCronJob(name, {
            target: methodRef,
            rule,
            locker,
            options,
        });
    }
};
SchedulerOrchestrator = tslib_1.__decorate([
    (0, common_1.Injectable)(),
    tslib_1.__metadata("design:paramtypes", [scheduler_registry_1.SchedulerRegistry,
        schedule_wrapper_1.ScheduleWrapper])
], SchedulerOrchestrator);
exports.SchedulerOrchestrator = SchedulerOrchestrator;
