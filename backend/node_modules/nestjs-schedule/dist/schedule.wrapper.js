"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScheduleWrapper = void 0;
const tslib_1 = require("tslib");
const common_1 = require("@nestjs/common");
const schedule_messages_1 = require("./schedule.messages");
const logger = new common_1.Logger('Schedule');
class ScheduleWrapper {
    immediately(name, target) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            (yield target)
                .call(null)
                .catch(e => logger.error((0, schedule_messages_1.JOB_EXECUTE_ERROR)(name), e));
            return target;
        });
    }
    retryable(target, retries = -1, retry = 5000) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let count = 0;
            let timer;
            const targetRef = () => {
                return new Promise((resolve, reject) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    const wrapperRef = () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                        try {
                            yield (yield target).call(null);
                            count = 0;
                            resolve();
                        }
                        catch (e) {
                            if (count < retries) {
                                if (timer) {
                                    clearTimeout(timer);
                                }
                                count++;
                                timer = setTimeout(() => wrapperRef(), retry);
                                return;
                            }
                            count = 0;
                            reject(e);
                        }
                    });
                    yield wrapperRef();
                }));
            };
            return targetRef;
        });
    }
    lockable(target, name, locker) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                if (locker) {
                    try {
                        const locked = yield locker.tryLock(name);
                        if (!locked) {
                            logger.warn((0, schedule_messages_1.TRY_LOCK_FAILED)(name));
                            return;
                        }
                        yield (yield target).call(null);
                        yield locker.release(name);
                    }
                    catch (e) {
                        logger.error((0, schedule_messages_1.JOB_EXECUTE_ERROR)(name), e);
                    }
                }
                else {
                    yield (yield target).call(null);
                }
            });
        });
    }
}
exports.ScheduleWrapper = ScheduleWrapper;
